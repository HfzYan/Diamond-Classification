# -*- coding: utf-8 -*-
"""Final_DiamondClassification_MuhammadHafizhYanuardi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MdLDvjOCRCxf3eH79VN4r8jxONEBn0kn

**Dicoding Final Submission: Belajar Pengembangan Machine Learning**  

> **Nama**     : Muhammad Hafizh Yanuardi

> **Domisili** : Kota Banjarmasin

Mengimport berbagai library untuk digunakan pada project
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
import pathlib
import os
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import numpy as np
from google.colab import files
from tensorflow.keras.preprocessing import image
import matplotlib.image as mpimg
# %matplotlib inline

"""Memount Google Drive untuk dapat digunakan pada proyek

"""

drive.mount('/content/drive/')

"""*   Mengimport dataset





"""

# memasukkan direktori awal

base_dir = './drive/MyDrive/Colab_Notebooks/diamond_images/'

# Melihat nama-nama folder di directory

os.listdir(base_dir)

train_dir = base_dir

"""*   Melakukan Generate Image


"""

train_datagen = ImageDataGenerator(
    rescale=1./225,
    rotation_range=20,
    horizontal_flip=True,
    vertical_flip=True,
    zoom_range=0.2,
    shear_range=0.3,
    fill_mode='nearest',
    validation_split=0.2

)

train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(150,150),
    batch_size=16,
    classes=['emerald','heart','pear'],
    class_mode='categorical',
    subset='training'
)

validation_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(150,150),
    batch_size=16,
    classes=['emerald','heart','pear'],
    class_mode='categorical',
    subset='validation'

)

"""*   Membuat model Convolutional Neural Network menggunakan Tensorflow


"""

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), activation='relu',input_shape=(150,150,3)),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Conv2D(256, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Flatten(),

    tf.keras.layers.Dense(256, activation='relu'),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(3, activation='softmax')
])

model.summary()

model.compile(
    loss='categorical_crossentropy',
    optimizer=tf.optimizers.Adam(),
    metrics=['accuracy']
)

"""*   Menggunakan Callback untuk mengontrol proses training


"""

# Commented out IPython magic to ensure Python compatibility.
from tensorflow.keras.callbacks import Callback
from timeit import default_timer as timer

# Callback untuk menghentikan training ketika akurasi validasi diatas 92%.
# Dalam kode ditambahkan 0.01% untuk memastikan bahwa akurasi lebih dari 92.00%
class ValAccCallback(Callback):
    def on_epoch_end(self, epoch, logs={}):
        if(logs.get('val_accuracy') >= 0.9201 and logs.get('accuracy') >= 0.9201):
          self.model.stop_training = True
          print("\n[accuracy | val_accuracy yang didapatkan senilai %2.2f%% | %2.2f%%, training dihentikan.]\n"
#                 % ((logs.get('accuracy')*100), (logs.get('val_accuracy')*100)))

        else:
          print("\n[accuracy | val_accuracy yang didapatkan senilai %2.2f%% | %2.2f%%, lanjut ke epoch berikutnya]\n"
#                 % ((logs.get('accuracy')*100), (logs.get('val_accuracy')*100)))

val_acc_callback = ValAccCallback()

"""*   Melakukan Training


"""

history = model.fit(
    train_generator,
    steps_per_epoch=100,
    epochs=15,
    validation_data=validation_generator,
    validation_steps=50,
    verbose=1,
    callbacks=[val_acc_callback],
)

import matplotlib.pyplot as plt

# Menampilkan output dari training

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss = history.history['loss']
val_loss = history.history['val_loss']

plt.figure(figsize=(8, 8))
plt.subplot(2, 1, 1)
plt.plot(acc, label='Akurasi Training')
plt.plot(val_acc, label='Akurasi Validation')
plt.legend(loc='lower right')
plt.ylabel('Akurasi')
plt.ylim([min(plt.ylim()),1])
plt.title('Akurasi Training dan Validation')

plt.subplot(2, 1, 2)
plt.plot(loss, label='Training Loss')
plt.plot(val_loss, label='Validation Loss')
plt.legend(loc='upper right')
plt.ylabel('Cross Entropy')
plt.ylim([0,1.0])
plt.title('Training dan Validation Loss')
plt.xlabel('epoch')
plt.show()

"""*   Prediksi isyarat tangan menggunakan model


"""

uploaded = files.upload()

for fn in uploaded.keys():

  path = fn
  img = image.load_img(path, target_size=(150,150))

  imgplot = plt.imshow(img)
  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)
  images = np.vstack([x])

  #Melakukan prediksi
  prediction = model.predict(images, batch_size=10)

  #Mengolah output agar dapat diprint
  classes = ['emerald','heart','pear']
  results = str(prediction[0]).strip("[].").replace(" ","").split('.')
  results = [int(results[i]) for i in range(len(results))]

  #Melakukan print hasil prediksi
  for i in range(len(results)):
    if results[i] == 1:
      print(classes[i])
      break

"""Menyimpan Model dengan format **.tflite**"""

# Menyimpan model dalam format SavedModel
export_dir = 'saved_model/'
tf.saved_model.save(model, export_dir)

# Convert SavedModel menjadi diamonds.tflite
converter = tf.lite.TFLiteConverter.from_saved_model(export_dir)
tflite_model = converter.convert()

tflite_model_file = pathlib.Path('diamonds.tflite')
tflite_model_file.write_bytes(tflite_model)